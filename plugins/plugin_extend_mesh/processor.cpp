#include <QFile>
#include <QTextStream>
#include <QTime>
#include <QtMath>
#include <cstdio>
#include <QDebug>
#include <QMap>
#include "processor.h"
//by TCJ
/*#include <QtSvg/QSvgGenerator>*/

Processor::Processor(const bool is_outline)
{    

    is_outline_flag = is_outline;

}

void Processor::set_paths(const QString gerber_file, const QString output_folder){

    QString extension = "." + image_format;
    name_of_gerber_file = gerber_file;//输入文件(全路径)
    output_folder_path = output_folder;
    name_of_output_file = output_folder + gerber_file.right(gerber_file.size() - gerber_file.lastIndexOf('/')) + extension;//输出文件（全路径）
}

int Processor::sqrt_from_big_int(const long long int value){

    double const eps = 0.1;
    double const start_value = 1;
    double height = start_value;
    double width = value;
    while (abs(width-height)>eps){
        height = (height+width)/2;
        width = value/height;
    }
    return int(height);

}

int Processor::radius_from_big_I_J(const long long i, const long long j){

    return sqrt_from_big_int(abs(i*i+j*j));

}

void Processor::set_dpi(const int new_scale){

    dpi = new_scale;

}

void Processor::set_frame_thickness(const double fr_in_mm){

    frame_thickness = fr_in_mm/mm_in_inch;

}


void Processor::set_w_h_dx_dy(const double wdt, const double hgt, const double dxx, const double dyy){
    w=wdt;
    h=hgt;
    dx=dxx;
    dy=dyy;
}

void Processor::set_opacity_value(const float val){

    opacity_value = val;

}

void Processor::set_image_format(const QString format){

    image_format = format;

}

QString Processor::get_outline_filename(){

    return name_of_output_file;

}

void Processor::set_outline_file_name(const QString filename){

    name_of_outline_file = filename;

}

int Processor::load_file(){//文件读取
    QFile file(name_of_gerber_file);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)){
        qDebug()<<"Gerber-文件 " << name_of_gerber_file << " 不能打开!也许它根本不存在。.";
        return -1;
    }
    while(!file.atEnd()) {
        QByteArray line = file.readLine();        
        list_of_strings_of_gerber.append(line);
    }
    file.close();
    //qDebug() << list_of_strings_of_gerber;
    return list_of_strings_of_gerber.size();

}

int Processor::processing() {

    //  return 1    : 文件完成成功
    //  return -1   : 日志错误(如：文件读取出错，)
    //  return -2   : gerber文件中错误, 文件格式错误!
    //  return -3   : painter没有启动. 也许文件太大了.
    //  return -4   : 图像没有保存下来. 也许文件太大了.

    if (list_of_strings_of_gerber.isEmpty()) {
        qDebug() << "Gerber文件 " << name_of_gerber_file << " 不能处理, 因为文件行的容器是空的!";
        gerberFilefinished(nullptr,-1);
        return -1;
    }

    //
    //  检查FS和mo指令的唯一输入, 否则，就错了.
    //
    int count_of_FS = 0, count_of_MO = 0;
    double k_mm_or_inch = 1;  //  因数. 如果单位是毫米, 这是每英寸一毫米的量。(英寸单位)

    //for (int i=0;i<list_of_strings_of_gerber.size();i++) {
    for (const QString& line : list_of_strings_of_gerber)
    {
        if (line.contains("%FS")){
            count_of_FS++;
        }
        if (line.contains("%MO")) {
            count_of_MO++;
            if (line.mid(3,2).contains("MM")) {//(毫米单位)
                k_mm_or_inch = mm_in_inch;
            }            
        }
    }
    if (!((count_of_FS==1)&&(count_of_MO==1))){
        qDebug()<<"Gerber文件 " << name_of_gerber_file << " 它不包含FS或MO(或超过一个)命令，也不能处理";
        gerberFilefinished(nullptr,-2);
        return -2;
    }

    //
    //  初始绘画装置
    //

    //  画布尺寸(板块+框架尺寸)
    frame_thickness = frame_thickness*k_mm_or_inch;     //  板块轮廓周围的字段厚度为英寸。
    board_width = w + frame_thickness*2;                //  裙子宽度+ 英寸的框架
    board_height = h + frame_thickness*2;               //  裙子高度+ 英寸的框架

    //  创造一个大的QImage，。板的分辨率和尺寸，单位(毫米或英寸)
    QImage pxmp(qRound(board_width*dpi/k_mm_or_inch), qRound(board_height*dpi/k_mm_or_inch), QImage::Format_RGB16);

    //---------------------by TCJ
/*    QSvgGenerator generator;
    QString t_fileName = name_of_output_file.replace(image_format,"svg");
    //qDebug() << "save filename:" << t_fileName;
    generator.setFileName(t_fileName);
    generator.setSize(QSize(qRound(board_width*dpi/k_mm_or_inch), qRound(board_height*dpi/k_mm_or_inch)));
    generator.setViewBox(QRect(0, 0, qRound(board_width*dpi/k_mm_or_inch), qRound(board_height*dpi/k_mm_or_inch)));
    //generator.setTitle("SVG Example");
    generator.setDescription("This SVG file is generated by Qt5.13.1");*/
    //---------------------
    //  如果有一个电路的图像，我们可以在上面画出来。否则，我们就创造了一个纯pixmap。
    if (name_of_outline_file!=""){
        if (pxmp.load(name_of_outline_file)){
            // 电路已成功加载。
        }
        else {
            // 没有电路图像
            pxmp.fill(Qt::white);
        }
    }
    else {
        pxmp.fill(Qt::white);
        if (is_outline_flag == false) {
           //
        }
    }

    //  绘画工具装置
    QPainter painter;
    //----------by TCJ
/*    painter.begin(&generator);*/
    painter.begin(&pxmp);
    //--------
    if (!painter.isActive()){
        // 错误
        qDebug()<<"QPainter 没有启动. Gerber文件 " << name_of_gerber_file << " 不能处理!";
        gerberFilefinished(nullptr,-3);
        return -3;
    }
    painter.setOpacity(qreal(opacity_value));    // 透明度
    painter.translate((frame_thickness-dx)*dpi/k_mm_or_inch,((board_height+dy-frame_thickness)*dpi/k_mm_or_inch));    //  Y轴反射，开始坐标在左下角和必要的偏移。

    QPen global_pen(Qt::black, 5, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin);  //  创造一个带有默认设置的全球笔
    painter.setPen(global_pen);
    painter.scale((1/k_mm_or_inch),(-1/k_mm_or_inch));

    //
    //
    //  主周期-所有字符串处理
    //
    //

    int i=0;                                        //  行计数器
    int command=0;                                  //  enum命令列表中的命令
    int int_unit;                                   //  enum units列表中的单元
    int int_mirr;                                   //  enum镜像模式
    QString str;                                    //  文件当前行
    QString str_command = "";                       //  指令行，指令行
    QMap<int,Aperture*> aperture_dictionary;        //  孔径字典。曲柄指示器同步
    QMap<QString,am_template*> am_template_dictionary;     //  宏观样板字典
    current_d_code = 1;
    while (i<list_of_strings_of_gerber.size()) {

        str = list_of_strings_of_gerber.at(i);      //  文件中的每一行
        if (str.contains("G04")){
            //  G04 . 什么都不做.
        }
        //
        // 测试是否有一个扩展命令以%开头
        //
        else {
            if (str.contains("%")){
                str_command = str.mid(1,2);                             //  两个符号扩展指令 FS.., MO.., AD..等等
                command = string_to_extended_command(str_command);      //
                //
                //  扩展gerber指令实现 %...:
                //
                switch (command) {
                    case FS :{
                    //----------
                    //   FS
                    //----------                        
                        frmt_x_int = 3;                         //  整数总是3, 为了避免与实际坐标数据不一致的格式
                        frmt_x_dec = str.mid(7,1).toInt();      //  количество разрядов после запятой
                        frmt_y_int = 3;                         //  整数总是3, 为了避免与实际坐标数据不一致的格式
                        frmt_y_dec = str.mid(10,1).toInt();     //  количество разрядов после запятой

                        //  测试超出容许放电值…
                        if ((frmt_x_int>7)||(frmt_x_dec>6)||(frmt_y_int>7)||(frmt_y_dec>6)||((str.mid(12,1)!="%"))){
                            qDebug()<<"指令不规则格式 FS. Gerber-文件 " << name_of_gerber_file << " 不能处理!";
                            gerberFilefinished(nullptr,-2);
                            return -2;
                        }

                    }break;
                    case MO :{
                    //----------
                    //   MO
                    //----------                        
                        int_unit = string_to_units(str.mid(3,2));
                        switch (int_unit){
                            case MM : unit = MM; break;
                            case IN : unit = IN; break;
                            default :
                            qDebug()<<"不正确的测量单位在 MO中. Gerber-文件 " << name_of_gerber_file << " 不能处理!";
                            gerberFilefinished(nullptr,-2);
                            return -2;
                        }
                    }break;
                    case AD :{
                    //----------
                    //   AD
                    //----------
                        QString d_code_number_of_aperture = "";
                        int int_d_code_of_aperture = 0;
                        QString name_of_aperture_template = "";
                        QString type_of_aperture_template = "";     //  比如孔径
                        QString modifiers = "";                     //  在命令行中可用的修改器(分号)
                        int aprt_temp_index = -1;                   //  命令行中的第一个符号索引
                        am_template* am_pointer = nullptr;          //  显示当前宏观模式的缓冲。默认情况下，没有宏观模式。

                        //
                        //  曲率读出，曲率开始索引
                        //
                        for (int i=4;i<str.size();i++) {
                            if (str.at(i).isDigit()){
                                d_code_number_of_aperture.append(str.at(i));
                            }
                            else if (d_code_number_of_aperture.isEmpty()){
                                qDebug()<< "指令中的空d-code在 AD. Gerber-文件 " << name_of_gerber_file << " 不能处理!";
                                gerberFilefinished(nullptr,-2);
                                return -2;
                            }
                            else {
                                aprt_temp_index = i;
                                break;
                            }
                        }
                        int_d_code_of_aperture = d_code_number_of_aperture.toInt();
                        //
                        //  修改行读出
                        //
                        if (str.contains(',')){
                            for (int i=str.indexOf(',')+1;(str.at(i)!='*')&&(str.at(i)!=',');i++) {
                                modifiers.append(str.at(i));
                            }
                        }
                        //
                        //  读出曲目模板的名字， 定义他的类型(以字符串的形式: 标准模板 C, R, O, P 或宏观样板)
                        //
                        for (int i=aprt_temp_index;(str.at(i)!='*')&&(str.at(i)!=',');i++) {
                            name_of_aperture_template.append(str.at(i));
                        }
                        if ((name_of_aperture_template.size()==1)&&(name_of_aperture_template=='C'||name_of_aperture_template=='R'||name_of_aperture_template=='O'||name_of_aperture_template=='P')){
                            type_of_aperture_template = name_of_aperture_template;
                        }
                        else{
                            type_of_aperture_template = "MACRO";
                            //
                            //  搜索“宏观模板”字典是一个有名字的模板。如果你找到了，它就在buffpointer上。
                            //
//                            for (int i=0; i<am_template_dictionary.size(); i++) {
//                                if (name_of_aperture_template == am_template_dictionary.at(i)->get_name()){
//                                    am_pointer = am_template_dictionary.at(i);
//                                    break;
//                                }
//                            }
                            am_pointer = am_template_dictionary.find(name_of_aperture_template).value();
                            if (am_pointer == nullptr){
                                qDebug()<<"在宏观曲柄字典中发现了一个空元素. Gerber-文件 " << name_of_gerber_file << " 不能处理!";
                                gerberFilefinished(nullptr,-2);
                                return -2;
                            }
                        }
                        //
                        //  创建曲目，并将其添加到aperture_dictionary字典中。
                        //
                        Aperture *new_aperture = new Aperture(int_d_code_of_aperture, name_of_aperture_template, type_of_aperture_template, modifiers, am_pointer);
                        new_aperture->create(dpi);
                        aperture_dictionary.insert(int_d_code_of_aperture, new_aperture);
                    }break;
                    //----------
                    //   AM
                    //----------
                    case AM :{
                        QString name_of_am_template = "";
                        QStringList data_blocks;
                        //
                        //  宏观样板读出
                        //
                        for (int j=3;(str.at(j)!='*');j++) {
                            name_of_am_template.append(str.at(j));
                        }
                        if (name_of_am_template.isEmpty()){
                            qDebug()<<"无法读取团队中的宏观模式名称在 AM. Gerber-文件 " << name_of_gerber_file << " 不能处理!";
                            gerberFilefinished(nullptr,-2);
                            return -2;
                        }
                        //
                        //  数据读出滑车
                        //

                        //  运行周期从%AM到%
                        int percent_counter=0;
                        while (percent_counter<2) {
                            str = list_of_strings_of_gerber.at(i);
                            data_blocks.append(str.split('*'));
                            percent_counter=percent_counter+str.count('%');
                            if (percent_counter == 1)
                                i++;
                        }
                        //  检查空白或不需要的字符串并将其从页面中删除(例如宏模板或标识“%模板”结尾的字符串)
                        for (int j=0; j<data_blocks.size();) {
                            if (!((data_blocks.at(j).at(0).isDigit())||(data_blocks.at(j).at(0)=='$'))){
                                data_blocks.removeAt(j);
                            }
                            else {
                                j++;
                            }
                        }
                        //
                        // 创建一个模板，并添加到am_template_dictionary字典中
                        //
                        am_template *new_am_template = new am_template(name_of_am_template,data_blocks);
                        am_template_dictionary.insert(name_of_am_template, new_am_template);
                    }break;
                    case AB :{

                    }break;
                    case LP :{
                    //----------
                    //   LP
                    //----------
                        if (str.at(3)=='C'){
                            polarity = C;
                            painter.setBrush(Qt::white);
                        }
                        else if (str.at(3)=='D'){
                            polarity = D;
                            painter.setBrush(Qt::black);
                        }
                        else {
                            qDebug()<<"指令不规则格式 LP. Gerber-文件 " << name_of_gerber_file << " 不能处理!";
                            gerberFilefinished(nullptr,-2);
                            return -2;
                        }
                    }break;
                    case LM :{
                    //----------
                    //   LM
                    //----------
                        int_mirr = string_to_mirroring(str.mid(3,2));
                        switch (int_mirr) {
                            case NO_MIRRORING : mirroring = NO_MIRRORING; break;
                            case X : mirroring = X; break;
                            case Y : mirroring = Y; break;
                            case XY : mirroring = XY; break;
                        }
                    }break;
                    case LR :{

                    }break;
                    case LS :{

                    }break;
                    case TF :{

                    }break;
                    case TO :{

                    }break;
                    case TD :{

                    }break;
                }//end of switch
            }//end of if (str.contains("%"))

            //
            // D -代码搜索
            //

            else if (str.contains("D")||str.contains("X")||str.contains("Y")) {
//                current_d_code = 1;
                if (str.contains("D")){
                str_command = str.mid(str.indexOf('D'),3);  // D..(01, 02, 03, nn)
                command = string_to_command(str_command);
                }
                else {
                    if (command==2) {
//                        qDebug()<< "coordinate data without operation code detected...";
//                        qDebug()<< str.contains("D") << "command:" <<command;
//                        qDebug()<< "number of string:0" << i;
                    }

//                    command = current_d_code;               //  deprecated mentor...
//                    command = D01;
                }
                check_for_G_in_D(str,&interpolation_mode);          //  deprecated mentor...

                switch (command) {
                    case D01 :{
                    //----------
                    //   D01
                    //----------
//                        current_d_code = 1;                                 //  deprecated mentor...
//                        check_for_G_in_D(str,&interpolation_mode);          //  deprecated mentor...
                        int command_x = current_x, command_y = current_y;   //  新坐标。默认情况下，接受当前坐标的值。
                        int command_i = 0, command_j = 0;                   //  偏移(弧中心)

                        //  读指令行中的新坐标
                        if (str.contains('X')){
                            QString x_val;
                            bool minus=0;
                            if ((str.at(str.indexOf('X')+1)) == '-')
                                minus = 1;
                            for (int i=str.indexOf('X') + minus + 1; str.at(i).isDigit();i++) {
                                x_val.append(str.at(i));
                            }
                            command_x = trim_D_argument(x_val, frmt_x_int, frmt_x_dec, minus);
                        }
                        if (str.contains('Y')){
                            bool minus=0;
                            QString y_val;
                            if ((str.at(str.indexOf('Y')+1))=='-')
                                minus = 1;
                            for (int i=str.indexOf('Y') + minus + 1; str.at(i).isDigit();i++) {
                                y_val.append(str.at(i));
                            }
                            command_y = trim_D_argument(y_val, frmt_y_int, frmt_y_dec, minus);
                        }
                        if (str.contains('I')){
                            QString i_val;
                            bool minus=0;
                            if ((str.at(str.indexOf('I')+1))=='-')
                                minus = 1;
                            for (int i=str.indexOf('I') + minus + 1; str.at(i).isDigit();i++) {
                                i_val.append(str.at(i));
                            }
                            command_i = trim_D_argument(i_val, frmt_x_int, frmt_x_dec, minus);
                        }
                        if (str.contains('J')){
                            bool minus=0;
                            QString j_val;
                            if ((str.at(str.indexOf('J')+1))=='-')
                                minus = 1;
                            for (int i=str.indexOf('J') + minus + 1; str.at(i).isDigit();i++) {
                                j_val.append(str.at(i));
                            }
                            command_j = trim_D_argument(j_val, frmt_y_int, frmt_y_dec, minus);
                        }
                        //
                        // 模式绘画 LINEAR
                        //
                        if (interpolation_mode == LINEAR){
                            painter.drawLine(current_x, current_y, command_x, command_y);
                        }
                        //
                        // 模式绘画 CLOCKWISE_CIRCULAR
                        //
                        else if (interpolation_mode == CLOCKWISE_CIRCULAR){
                            // 圆弧半径
                            int R = radius_from_big_I_J(command_i,command_j);
                            // 弧中心坐标:
                            int Cx = 0;
                            int Cy = 0;
                            // 开始和结束弧角:
                            int start_angle = 0;
                            int end_angle = 0;
                            int span_angle = 0;

                            if (quadrant_mode == SINGLE_QUADRANT){
                                // 计算初角，最终角，弧中心:
                                //1 кв.
                                if ((current_x < command_x)&&(current_y > command_y)){
                                    Cx = current_x - command_i;
                                    Cy = current_y - command_j;
                                    start_angle = qRound(atan2(command_j,command_i)*16*180/pi);
                                    end_angle = qRound(atan2(command_y-Cy, command_x-Cx)*16*180/pi);
                                }
                                //4 кв.
                                else if ((current_x > command_x)&&(current_y > command_y)){
                                    Cx = current_x - command_i;
                                    Cy = current_y + command_j;
                                    start_angle = qRound(-atan2(command_j,command_i)*16*180/pi);
                                    end_angle = qRound(-atan2(Cy-command_y, command_x-Cx)*16*180/pi);
                                }
                                //3 кв.
                                else if ((current_x > command_x)&&(current_y < command_y)){
                                    Cx = current_x + command_i;
                                    Cy = current_y + command_j;
                                    start_angle = 180*16 + qRound(atan2(command_j,command_i)*16*180/pi);
                                    end_angle = 180*16 + qRound(atan2(Cy-command_y, Cx-command_x)*16*180/pi);
                                }
                                //2 кв.
                                else {
                                    Cx = current_x + command_i;
                                    Cy = current_y - command_j;
                                    start_angle = 180*16 - qRound(atan2(command_j,command_i)*16*180/pi);
                                    end_angle = 180*16 - qRound(atan2(command_y-Cy, Cx-command_x)*16*180/pi);
                                }
                                // 一个矩形(Qt- doogi)，里面有一个弧:
                                QRect arc_rect(Cx-R, Cy-R, R*2, R*2);
                                // 弧角:
                                span_angle = end_angle - start_angle;
                                // 测试弧值从0度到90度的输出:
                                if (qAbs(span_angle)>90*16){
                                    if (span_angle<0) span_angle = -90*16;
                                    else {span_angle = 90*16;}
                                }
                                // 弧图形:
                                painter.drawArc(arc_rect, -start_angle, -span_angle);
                            }
                            else if (quadrant_mode == MULTI_QUADRANT){
                                // 弧中心坐标:
                                int Cx = current_x + command_i;
                                int Cy = current_y + command_j;
                                // 电弧内接矩形:
                                QRect arc_rect(Cx-R, Cy-R, R*2, R*2);
                                // 弧角:
                                start_angle = qRound(atan2(-command_j,-command_i)*16*180/pi);
                                end_angle = qRound(atan2(command_y-Cy, command_x-Cx)*16*180/pi);
                                // 将角度设为0…360
                                norm_angle(&start_angle);
                                norm_angle(&end_angle);
                                if (start_angle<=end_angle){
                                    span_angle = end_angle - (start_angle + 360*16);
                                }
                                else {
                                    span_angle = end_angle - start_angle;
                                }
                                //  弧图形:
                                painter.drawArc(arc_rect, -start_angle, abs(span_angle));
                            }
                            else {
                                //  错误，象限模式未指定!
                                qDebug()<<"错误!四边形模式没有指定 Gerber-文件 " << name_of_gerber_file << " 不能处理!";
                                gerberFilefinished(nullptr,-1);
                                return -1;
                            }
                        }
                        //---------------------------------------------------------------
                        // 模式绘画COUNTERCLOCKWISE_CIRCULAR
                        //---------------------------------------------------------------
                        else if (interpolation_mode==COUNTERCLOCKWISE_CIRCULAR){
                            int R = radius_from_big_I_J(command_i,command_j);
                            int Cx = 0;
                            int Cy = 0;
                            int start_angle = 0;
                            int end_angle = 0;
                            int span_angle = 0;

                            if (quadrant_mode == SINGLE_QUADRANT){
                                // 计算初角，最终角，弧中心:
                                //  1 кв.
                                if ((current_x > command_x)&&(current_y < command_y)){
                                    Cx = current_x - command_i;
                                    Cy = current_y - command_j;
                                    start_angle = qRound(atan2(command_j,command_i)*16*180/pi);
                                    end_angle = qRound(atan2(command_y-Cy, command_x-Cx)*16*180/pi);
                                }
                                //  4 кв.
                                else if ((current_x < command_x)&&(current_y < command_y)){
                                    Cx = current_x - command_i;
                                    Cy = current_y + command_j;
                                    start_angle = qRound(-atan2(command_j,command_i)*16*180/pi);
                                    end_angle = qRound(-atan2(Cy-command_y, command_x-Cx)*16*180/pi);
                                }
                                //  3 кв.
                                else if ((current_x < command_x)&&(current_y > command_y)){
                                    Cx = current_x + command_i;
                                    Cy = current_y + command_j;
                                    start_angle = 180*16 + qRound(atan2(command_j,command_i)*16*180/pi);
                                    end_angle = 180*16 + qRound(atan2(Cy-command_y, Cx-command_x)*16*180/pi);
                                }
                                //  2кв.
                                else {
                                    Cx = current_x + command_i;
                                    Cy = current_y - command_j;
                                    start_angle = 180*16 - qRound(atan2(command_j,command_i)*16*180/pi);
                                    end_angle = 180*16 - qRound(atan2(command_y-Cy, Cx-command_x)*16*180/pi);
                                }

                                QRect arc_rect(Cx-R, Cy-R, R*2, R*2);
                                span_angle = end_angle - start_angle;
                                if (qAbs(span_angle)>90*16){
                                    if (span_angle<0) span_angle = -90*16;
                                    else {span_angle = 90*16;}
                                }
                                painter.drawArc(arc_rect, -start_angle, -span_angle);
                            }
                            else if (quadrant_mode == MULTI_QUADRANT){
                                int Cx = current_x + command_i;
                                int Cy = current_y + command_j;
                                QRect arc_rect(Cx-R, Cy-R, R*2, R*2);
                                start_angle = qRound(atan2(-command_j,-command_i)*16*180/pi);
                                end_angle = qRound(atan2(command_y-Cy, command_x-Cx)*16*180/pi);
                                norm_angle(&start_angle);
                                norm_angle(&end_angle);
                                if (start_angle >= end_angle){
                                    span_angle = (end_angle + 360*16) - start_angle;
                                }
                                else {
                                    span_angle = end_angle - start_angle;
                                }
                                painter.drawArc(arc_rect, -start_angle, -abs(span_angle));
                            }
                            else {
                                //  错误，象限模式没有设定!
                                qDebug()<<"错误!四边形模式没有指定. Gerber-文件 " << name_of_gerber_file << " 不能处理!";
                                gerberFilefinished(nullptr,-1);
                                return -1;
                            }
                        }
                        else {
                            //  错误，没有设定插值模式!
                            qDebug()<<"错误!Interpolation模式没有指定 Gerber-文件 " << name_of_gerber_file << " 不能处理!";
                            gerberFilefinished(nullptr,-1);
                            return -1;
                        }

                        //  当前坐标点更新
                        current_x = command_x;
                        current_y = command_y;

                    }break;
                    case D02 :{
                    //----------
                    //   D02
                    //----------
//                    current_d_code = 1;                         //  deprecated mentor...
                    check_for_G_in_D(str,&interpolation_mode);  //  deprecated mentor...
                    if (str.contains('X')){
                        QString x_val;
                        bool minus=0;
                        if ((str.at(str.indexOf('X')+1))=='-')
                            minus = 1;
                        for (int i=str.indexOf('X') + minus + 1; str.at(i).isDigit();i++) {
                            x_val.append(str.at(i));
                        }
                        current_x = trim_D_argument(x_val, frmt_x_int, frmt_x_dec, minus);
                    }
                    if (str.contains('Y')){
                        bool minus=0;
                        QString y_val;
                        if ((str.at(str.indexOf('Y')+1))=='-')
                            minus = 1;
                        for (int i=str.indexOf('Y') + minus + 1; str.at(i).isDigit();i++) {
                            y_val.append(str.at(i));
                        }
                        current_y = trim_D_argument(y_val, frmt_y_int, frmt_y_dec, minus);
                    }
                    }break;
                    case D03 :{
                    //----------
                    //   D03
                    //----------                    
                        if (str.contains('X')){
                            QString x_val;
                            bool minus=0;
                            if ((str.at(str.indexOf('X')+1))=='-')
                                minus = 1;
                            for (int i=str.indexOf('X') + minus + 1; str.at(i).isDigit();i++) {
                                x_val.append(str.at(i));
                            }
                            current_x = trim_D_argument(x_val, frmt_x_int, frmt_x_dec, minus);
                        }
                        if (str.contains('Y')){
                            bool minus=0;
                            QString y_val;
                            if ((str.at(str.indexOf('Y')+1))=='-')
                                minus = 1;
                            for (int i=str.indexOf('Y') + minus + 1; str.at(i).isDigit();i++) {
                                y_val.append(str.at(i));
                            }
                            current_y = trim_D_argument(y_val, frmt_y_int, frmt_y_dec, minus);
                        }                        

                        current_aperture->draw_me(current_x,current_y,&painter);

                    }break;
                    case Dnn :{
                    //----------
                    //   Dnnn
                    //----------
                        //  D之后读数字..
                        QString number_of_Dnn;
                        for (int i=str.indexOf('D')+1;str.at(i).isDigit();i++) {
                            number_of_Dnn.append(str.at(i));
                        }
                        //  在d- code词典中查找这个。它的设置是当前的。
//                        for (int i=0;i<aperture_dictionary.size();i++) {
//                            if (aperture_dictionary.at(i)->get_d_code()==number_of_Dnn.toInt()){
//                                current_aperture = aperture_dictionary.at(i);
//                                break;
//                            }
//                        }
                        current_aperture = aperture_dictionary.find(number_of_Dnn.toInt()).value();

                        //在D01中设置与给定曲柄(如果是圆的话)相对应的羽毛参数
                        //如果文件是一个轮廓，那么顶点厚度将被忽略，以避免图像中非常微妙的轮廓
                        //**************************************************************
                            global_pen.setWidth(current_aperture->get_std_circ_dia_in_px(dpi));
                            painter.setPen(global_pen);
                        //**************************************************************
                    }break;
                }//end of switch
            }//end of else if (str.contains("D"))
            //---------------------------------------------------------------
            // G指令检查
            //---------------------------------------------------------------
            else if (str.contains("G")||str.contains("M")) {
                str_command = str.mid(0,3);
                command = string_to_command(str_command);
                switch (command) {
                    case G01 :{
                    //----------
                    //   G01
                    //----------
                        interpolation_mode = LINEAR;
                    }break;
                    case G02 :{
                    //----------
                    //   G02
                    //----------
                        interpolation_mode = CLOCKWISE_CIRCULAR;
                    }break;
                    case G03 :{
                    //----------
                    //   G03
                    //----------
                        interpolation_mode = COUNTERCLOCKWISE_CIRCULAR;
                    }break;
                    case G74 :{
                    //----------
                    //   G74
                    //----------
                        quadrant_mode = SINGLE_QUADRANT;
                    }break;
                    case G75 :{
                    //----------
                    //   G75
                    //----------
                        quadrant_mode = MULTI_QUADRANT;
                    }break;
                    case G36 :{
                        bool end_of_region = false;         // 该地区描述结束的标志。这是为了摆脱该地区的循环。
                        bool end_of_contour = false;        // 区域内当前电路处理结束的标志
                        bool creating_contour_now = false;  // 是否形成了轮廓
                        QList <QPainterPath*> contours;     // 该区域内轮廓的一系列指标.
                        QPointF startpoint;                 // 初始电路点变量(全球当前坐标，每个电路前)

                        //  区域主要加工周期
                        painter.save();
                        painter.setPen(Qt::NoPen);
                        while (!end_of_region) {
                            //轮廓
                            creating_contour_now = false;
                            end_of_contour = false;

                            while (!end_of_contour) {
                                //  如果电路现在还没有形成，D01命令就会启动一个新的电路。
                                str = list_of_strings_of_gerber.at(i);
                                if ((str.contains("D01"))&&(creating_contour_now == false)){
                                    startpoint.setX(current_x);
                                    startpoint.setY(current_y);
                                    QPainterPath* new_contour = new QPainterPath(startpoint);
                                    new_contour->setFillRule(Qt::WindingFill);
                                    contours.append(new_contour);
                                    creating_contour_now = true;
                                }

                                //................................................

                                if (str.contains("D")||str.contains("X")||str.contains("Y")){
                                    if (str.contains("D")){
                                    str_command = str.mid(str.indexOf('D'),3);  //D..(01, 02, 03, nn)
                                    command = string_to_command(str_command);
                                    }
                                    else {
                                        command = D01;               //  deprecated mentor...
                                    }
                                    switch (command) {
                                        //
                                        //   D01 for regions
                                        //
                                        case D01:{
//                                        current_d_code = 1;                               //  deprecated mentor...
                                        check_for_G_in_D(str,&interpolation_mode);          //  deprecated mentor...
                                        int command_x = current_x, command_y = current_y;   //  新坐标。默认情况下，接受当前坐标的值
                                        int command_i = 0, command_j = 0;                   //  偏移(弧中心)

                                        //读指令行中的新坐标
                                        if (str.contains('X')){
                                            QString x_val;
                                            bool minus=0;
                                            if ((str.at(str.indexOf('X')+1)) == '-')
                                                minus = 1;
                                            for (int i=str.indexOf('X') + minus + 1; str.at(i).isDigit();i++) {
                                                x_val.append(str.at(i));
                                            }
                                            command_x = trim_D_argument(x_val, frmt_x_int, frmt_x_dec, minus);
                                        }
                                        if (str.contains('Y')){
                                            bool minus=0;
                                            QString y_val;
                                            if ((str.at(str.indexOf('Y')+1))=='-')
                                                minus = 1;
                                            for (int i=str.indexOf('Y') + minus + 1; str.at(i).isDigit();i++) {
                                                y_val.append(str.at(i));
                                            }
                                            command_y = trim_D_argument(y_val, frmt_y_int, frmt_y_dec, minus);
                                        }
                                        if (str.contains('I')){
                                            QString i_val;
                                            bool minus=0;
                                            if ((str.at(str.indexOf('I')+1))=='-')
                                                minus = 1;
                                            for (int i=str.indexOf('I') + minus + 1; str.at(i).isDigit();i++) {
                                                i_val.append(str.at(i));
                                            }
                                            command_i = trim_D_argument(i_val, frmt_x_int, frmt_x_dec, minus);
                                        }
                                        if (str.contains('J')){
                                            bool minus=0;
                                            QString j_val;
                                            if ((str.at(str.indexOf('J')+1))=='-')
                                                minus = 1;
                                            for (int i=str.indexOf('J') + minus + 1; str.at(i).isDigit();i++) {
                                                j_val.append(str.at(i));
                                            }
                                            command_j = trim_D_argument(j_val, frmt_y_int, frmt_y_dec, minus);
                                        }

                                        if (interpolation_mode == LINEAR){
                                            contours.last()->lineTo(command_x,command_y);
                                        }

                                        else if (interpolation_mode == CLOCKWISE_CIRCULAR){
                                            int R = radius_from_big_I_J(command_i,command_j);

                                            int Cx = 0;
                                            int Cy = 0;
                                            
                                            int start_angle = 0;
                                            int end_angle = 0;
                                            int span_angle = 0;

                                            if (quadrant_mode == SINGLE_QUADRANT){                                              
                                                //  1 кв.
                                                if ((current_x < command_x)&&(current_y > command_y)){
                                                    Cx = current_x - command_i;
                                                    Cy = current_y - command_j;
                                                    start_angle = qRound(atan2(command_j,command_i)*16*180/pi);
                                                    end_angle = qRound(atan2(command_y-Cy, command_x-Cx)*16*180/pi);
                                                }
                                                //  4 кв.
                                                else if ((current_x > command_x)&&(current_y > command_y)){
                                                    Cx = current_x - command_i;
                                                    Cy = current_y + command_j;
                                                    start_angle = qRound(-atan2(command_j,command_i)*16*180/pi);
                                                    end_angle = qRound(-atan2(Cy-command_y, command_x-Cx)*16*180/pi);
                                                }
                                                //  3 кв.
                                                else if ((current_x > command_x)&&(current_y < command_y)){
                                                    Cx = current_x + command_i;
                                                    Cy = current_y + command_j;
                                                    start_angle = 180*16 + qRound(atan2(command_j,command_i)*16*180/pi);
                                                    end_angle = 180*16 + qRound(atan2(Cy-command_y, Cx-command_x)*16*180/pi);
                                                }
                                                //  2 кв.
                                                else {
                                                    Cx = current_x + command_i;
                                                    Cy = current_y - command_j;
                                                    start_angle = 180*16 - qRound(atan2(command_j,command_i)*16*180/pi);
                                                    end_angle = 180*16 - qRound(atan2(command_y-Cy, Cx-command_x)*16*180/pi);
                                                }
                                                
                                                QRect arc_rect(Cx-R, Cy-R, R*2, R*2);                                               
                                                span_angle = end_angle - start_angle;                                              
                                                if (qAbs(span_angle)>90*16){
                                                    if (span_angle<0) span_angle = -90*16;
                                                    else {span_angle = 90*16;}
                                                }                                               
                                                contours.last()->arcTo(arc_rect,-start_angle/16, -span_angle/16);
                                            }
                                            else if (quadrant_mode == MULTI_QUADRANT){                                             
                                                int Cx = current_x + command_i;
                                                int Cy = current_y + command_j;

                                                QRect arc_rect(Cx-R, Cy-R, R*2, R*2);

                                                start_angle = qRound(atan2(-command_j,-command_i)*16*180/pi);
                                                end_angle = qRound(atan2(command_y-Cy, command_x-Cx)*16*180/pi);

                                                norm_angle(&start_angle);
                                                norm_angle(&end_angle);
                                                if (start_angle<=end_angle){
                                                    span_angle = end_angle - (start_angle + 360*16);
                                                }
                                                else {
                                                    span_angle = end_angle - start_angle;
                                                }

                                                contours.last()->arcTo(arc_rect,-start_angle/16, abs(span_angle/16));
                                            }
                                            else {                                               
                                                qDebug()<<"错误!Quadrant模式在该地区没有指定。Gerber文件" << name_of_gerber_file << " 不能处理!";
                                                gerberFilefinished(nullptr,-1);
                                                return -1;
                                            }
                                        }
                                        
                                        else if (interpolation_mode==COUNTERCLOCKWISE_CIRCULAR){
                                            int R = radius_from_big_I_J(command_i,command_j);

                                            int Cx = 0;
                                            int Cy = 0;

                                            int start_angle = 0;
                                            int end_angle = 0;
                                            int span_angle = 0;

                                            if (quadrant_mode == SINGLE_QUADRANT){                                              
                                                //  1 кв.
                                                if ((current_x > command_x)&&(current_y < command_y)){
                                                    Cx = current_x - command_i;
                                                    Cy = current_y - command_j;
                                                    start_angle = qRound(atan2(command_j,command_i)*16*180/pi);
                                                    end_angle = qRound(atan2(command_y-Cy, command_x-Cx)*16*180/pi);
                                                }
                                                //  4 кв.
                                                else if ((current_x < command_x)&&(current_y < command_y)){
                                                    Cx = current_x - command_i;
                                                    Cy = current_y + command_j;
                                                    start_angle = qRound(-atan2(command_j,command_i)*16*180/pi);
                                                    end_angle = qRound(-atan2(Cy-command_y, command_x-Cx)*16*180/pi);
                                                }
                                                //  3 кв.
                                                else if ((current_x < command_x)&&(current_y > command_y)){
                                                    Cx = current_x + command_i;
                                                    Cy = current_y + command_j;
                                                    start_angle = 180*16 + qRound(atan2(command_j,command_i)*16*180/pi);
                                                    end_angle = 180*16 + qRound(atan2(Cy-command_y, Cx-command_x)*16*180/pi);
                                                }
                                                //  2кв.
                                                else {
                                                    Cx = current_x + command_i;
                                                    Cy = current_y - command_j;
                                                    start_angle = 180*16 - qRound(atan2(command_j,command_i)*16*180/pi);
                                                    end_angle = 180*16 - qRound(atan2(command_y-Cy, Cx-command_x)*16*180/pi);
                                                }

                                                QRect arc_rect(Cx-R, Cy-R, R*2, R*2);
                                                span_angle = end_angle - start_angle;

                                                if (qAbs(span_angle)>90*16){
                                                    if (span_angle<0) span_angle = -90*16;
                                                    else {span_angle = 90*16;}
//                                                        log << time.currentTime().toString() << " D01 command (region): warning! angle of Arc > 90 in SINGLE QUADRANT mode\n";
                                                }

                                                contours.last()->arcTo(arc_rect,-start_angle/16, -span_angle/16);
                                            }
                                            else if (quadrant_mode == MULTI_QUADRANT){                                               
                                                int Cx = current_x + command_i;
                                                int Cy = current_y + command_j;
                                                QRect arc_rect(Cx-R, Cy-R, R*2, R*2);
                                                start_angle = qRound(atan2(-command_j,-command_i)*16*180/pi);
                                                end_angle = qRound(atan2(command_y-Cy, command_x-Cx)*16*180/pi);
                                                norm_angle(&start_angle);
                                                norm_angle(&end_angle);
                                                if (start_angle >= end_angle){
                                                    span_angle = (end_angle + 360*16) - start_angle;
                                                }
                                                else {
                                                    span_angle = end_angle - start_angle;
                                                }
                                                contours.last()->arcTo(arc_rect,-start_angle/16, -abs(span_angle/16));
                                            }
                                            else {
                                                qDebug()<<"错误!Quadrant模式在该地区没有指定。Gerber文件" << name_of_gerber_file << " 不能处理!";
                                                gerberFilefinished(nullptr,-1);
                                                return -1;
                                            }
                                        }
                                        else {                      
                                            qDebug()<<"错误!该地区没有界面模式。Gerber文件" << name_of_gerber_file << " 不能处理!";
                                            gerberFilefinished(nullptr,-1);
                                            return -1;
                                        }

                                        current_x = command_x;
                                        current_y = command_y;
                                        }break;
                                        case D02:{
                                            //
                                            //   D02 for regions
                                            //
//                                            current_d_code = 2;     //  deprecated mentor
                                            check_for_G_in_D(str,&interpolation_mode); //   deprecated mentor...
                                            if (creating_contour_now == true){
                                                end_of_contour = true;
                                            }

                                            if (str.contains('X')){
                                                    QString x_val;
                                                    bool minus=0;
                                                    if ((str.at(str.indexOf('X')+1))=='-')
                                                        minus = 1;
                                                    for (int i=str.indexOf('X') + minus + 1; str.at(i).isDigit();i++) {
                                                        x_val.append(str.at(i));
                                                    }
                                                    current_x = trim_D_argument(x_val, frmt_x_int, frmt_x_dec, minus);
                                                }
                                            if (str.contains('Y')){
                                                bool minus=0;
                                                QString y_val;
                                                if ((str.at(str.indexOf('Y')+1))=='-')
                                                    minus = 1;
                                                for (int i=str.indexOf('Y') + minus + 1; str.at(i).isDigit();i++) {
                                                    y_val.append(str.at(i));
                                                }
                                                current_y = trim_D_argument(y_val, frmt_y_int, frmt_y_dec, minus);
                                            }
                                        }break;
                                    }//end of switch
                                }//end of if (str.contains("D"))
                                else if (str.contains("G")) {
                                    str_command = str.mid(str.indexOf('G'),3);
                                    command = string_to_command(str_command);
                                    switch (command) {
                                        case G01 :{
                                        //----------
                                        //   G01
                                        //----------
                                            interpolation_mode = LINEAR;
                                        }break;
                                        case G02 :{
                                        //----------
                                        //   G02
                                        //----------
                                            interpolation_mode = CLOCKWISE_CIRCULAR;
                                        }break;
                                        case G03 :{
                                        //----------
                                        //   G03
                                        //----------
                                            interpolation_mode = COUNTERCLOCKWISE_CIRCULAR;
                                        }break;
                                        case G74 :{
                                        //----------
                                        //   G74
                                        //----------
                                            quadrant_mode = SINGLE_QUADRANT;
                                        }break;
                                        case G75 :{
                                        //----------
                                        //   G75
                                        //----------
                                            quadrant_mode = MULTI_QUADRANT;
                                        }break;
                                    }//end of switch
                                }//end of if (str.contains("G"))

                                //................................................

                                if (str.contains("G37")){
                                    end_of_contour = true;
                                    end_of_region = true;
                                    //在循环中添加到contour数组中所有电路的总体图景中，它们被涂黑了。
                                    for (int i=0;i<contours.size();i++) {
                                        painter.fillPath(*contours.at(i),Qt::black);
                                        painter.drawPath(*contours.at(i));
                                    }
                                    //  动态存储器释放
                                    for (int i=0;i<contours.size();i++) {
                                        delete contours.at(i);
                                    }
                                  
                                    painter.restore();
                                    break;
                                }// end of if (str.contains("G37"))

                            i++;

                            }// end of while (!end_of_contour)
                        }// end of while (!end_of_region)

                    }break;
                    case M02 :{
                    //----------
                    //   M02
                    //----------
                    //文件完成成功
                    }break;
//                    default: log << time.currentTime().toString() << " Invalid command format: " << str_command.toUtf8() << "\n";
                }//end of switch
            }//end of else if (str.contains("G")||str.contains("M"))
        }//end of else (if (str.contains("G04")))

        //行计数器增加，新的迭代。
        i++;

    }//在文件中引用字符串的主周期结束

    //
    //
    //  以选择的图形格式保存在磁盘上
    //
    //

    painter.end();
    QFile file(name_of_output_file);
    file.open(QIODevice::WriteOnly);
    if (image_format == "bmp"){
        if (!pxmp.save(&file,"BMP")) {
            qDebug()<<"错误! Gerber-文件 " << name_of_gerber_file << ". 我们无法保存图像!";
            gerberFilefinished(nullptr,-4);
            return -4;
        }         //  BMP格式文件中的图像保存
    }
    else if (image_format == "png"){
        if (!pxmp.save(&file,"PNG")){
            qDebug()<<"错误! Gerber-文件 " << name_of_gerber_file << ". 无法保存图像!";
            gerberFilefinished(nullptr,-4);
            return -4;
        }         //  PNG格式文件中的图像保存
    }
    
    //
    //  动态存储器从字典中解放
    //
    aperture_dictionary.clear();
    am_template_dictionary.clear();
//    for (int i=0;i<aperture_dictionary.size();i++) {
//        delete aperture_dictionary.at(i);
//    }
//    for (int i=0;i<am_template_dictionary.size();i++) {
//        delete am_template_dictionary.at(i);
//    }

    gerberFilefinished(name_of_output_file,1);//  应用程序主窗口信号
    return 1;               //  格伯文件处理成功完成

}

int Processor::string_to_command(const QString str){

    if (str=="D01")       return D01;
    else if (str=="D02")  return D02;
    else if (str=="D03")  return D03;
    else if (str=="G01")  return G01;
    else if (str=="G02")  return G02;
    else if (str=="G03")  return G03;
    else if (str=="G74")  return G74;
    else if (str=="G75")  return G75;
    else if (str=="G36")  return G36;
    else if (str=="G37")  return G37;
    else if (str=="G04")  return G04;
    else if (str=="M02")  return M02;
    else if (str.contains('D'))  return Dnn;
    return -1;

}

int Processor::string_to_extended_command(const QString str){

    if (str=="FS")       return FS;
    else if (str=="MO")  return MO;
    else if (str=="AD")  return AD;
    else if (str=="AM")  return AM;
    else if (str=="AB")  return AB;
    else if (str=="LP")  return LP;
    else if (str=="LM")  return LM;
    else if (str=="LR")  return LR;
    else if (str=="LS")  return LS;
    else if (str=="TF")  return TF;
    else if (str=="TA")  return TA;
    else if (str=="TO")  return TO;
    else if (str=="TD")  return TD;
    return -1;

}

int Processor::string_to_units(const QString str){

    if (str=="MM")       return MM;
    else if (str=="IN")  return IN;
    return -1;

}

int Processor::string_to_mirroring(const QString str){

    if (str=="XY")                  return XY;
    else if(str.mid(1,1)=='*'||str.mid(1,1)=='%')
    {
        if (str.left(1)=='X')       return X;
        else if (str.left(1)=='Y')  return Y;
        else if (str.left(1)=='N')  return NO_MIRRORING;
    }
    return -1;

}

int Processor::trim_D_argument(QString str, const int int_format, const int dec_format, const bool minus){

    if (str.size()<(int_format+dec_format)) {
        int difference = int_format+dec_format-str.size();
        for (int i=0;i<difference;i++) {
            str = str.insert(0,'0');
        }
    }
    str = str.insert(int_format,'.');
    if (minus){
        str.insert(0,'-');
    }
    return qRound((str.toDouble())*dpi);

}

void Processor::norm_angle(int* angle){

    if (*angle<0){
         *angle = (360*16) + *angle;
    }

}

void Processor::check_for_G_in_D(const QString str, enum interpolation_mode* mode){

    if (str.contains("G01")||str.contains("G1")){
        *mode = LINEAR;
    }
    else if (str.contains("G02")||str.contains("G2")){
        *mode = CLOCKWISE_CIRCULAR;
    }
    else if (str.contains("G03")||str.contains("G3")){
        *mode = COUNTERCLOCKWISE_CIRCULAR;
    }

}

void Processor::get_outline_size(double *width, double *height, double *dx, double *dy){

    int min_x=2100000000, max_x=0, min_y=2100000000, max_y=0;
    int x_val, y_val;
    int frmt_int = 3, frmt_dec=1;
    QString str, str_val;
    bool minus=0;

    for (int i=0;i<list_of_strings_of_gerber.size();i++) {
        str = list_of_strings_of_gerber.at(i);
//        minus=false;
        //
        //  X
        //
        if (str.contains("%FS")){
            frmt_dec = str.mid(7,1).toInt();
        }
        if ((str.contains('X'))&&(!(str.contains('%')))&&(!(str.contains(',')))){
            minus=false;
            str_val="";
            if ((str.at(str.indexOf('X')+1)) == '-'){
                minus = true;
            }
            for (int i = str.indexOf('X') + minus + 1; str.at(i).isDigit();i++) {
                str_val.append(str.at(i));

            }
            x_val = trim_D_argument(str_val, frmt_int, frmt_dec, minus);
            if (x_val < min_x){
                min_x = x_val;
            }
            if (x_val > max_x) {
                max_x = x_val;
            }
        }
        //
        //  Y
        //
        if ((str.contains('Y'))&&(!(str.contains('%')))&&(!(str.contains(',')))){
            minus=false;
            str_val="";
            if ((str.at(str.indexOf('Y')+1)) == '-'){
                minus = true;
            }
            for (int i = str.indexOf('Y') + minus + 1; str.at(i).isDigit();i++) {
                str_val.append(str.at(i));
            }
            y_val = trim_D_argument(str_val, frmt_int, frmt_dec, minus);
            if (y_val < min_y){
                min_y = y_val;
            }
            if (y_val > max_y) {
                max_y = y_val;
            }
        }
    }
    // 结果

    *dx = double(min_x)/dpi;
    *dy = double(min_y)/dpi;

    *width = double(max_x-min_x)/dpi;
    *height = double(max_y-min_y)/dpi;

}

